// This file was generated by counterfeiter
package fake_bbs

import (
	"sync"
	"time"

	"github.com/cloudfoundry-incubator/runtime-schema/bbs"
	"github.com/cloudfoundry-incubator/runtime-schema/bbs/services_bbs"
	"github.com/pivotal-golang/lager"
	"github.com/tedsuo/ifrit"
)

type FakeConvergerBBS struct {
	NewConvergeLockStub        func(convergerID string, retryInterval time.Duration) ifrit.Runner
	newConvergeLockMutex       sync.RWMutex
	newConvergeLockArgsForCall []struct {
		convergerID   string
		retryInterval time.Duration
	}
	newConvergeLockReturns struct {
		result1 ifrit.Runner
	}
	ConvergeLRPsStub        func(logger lager.Logger, cellsLoader *services_bbs.CellsLoader)
	convergeLRPsMutex       sync.RWMutex
	convergeLRPsArgsForCall []struct {
		logger      lager.Logger
		cellsLoader *services_bbs.CellsLoader
	}
	ConvergeTasksStub        func(logger lager.Logger, timeToClaim, convergenceInterval, timeToResolve time.Duration, cellsLoader *services_bbs.CellsLoader)
	convergeTasksMutex       sync.RWMutex
	convergeTasksArgsForCall []struct {
		logger              lager.Logger
		timeToClaim         time.Duration
		convergenceInterval time.Duration
		timeToResolve       time.Duration
		cellsLoader         *services_bbs.CellsLoader
	}
	NewCellsLoaderStub        func() *services_bbs.CellsLoader
	newCellsLoaderMutex       sync.RWMutex
	newCellsLoaderArgsForCall []struct{}
	newCellsLoaderReturns     struct {
		result1 *services_bbs.CellsLoader
	}
	CellEventsStub        func() <-chan services_bbs.CellEvent
	cellEventsMutex       sync.RWMutex
	cellEventsArgsForCall []struct{}
	cellEventsReturns     struct {
		result1 <-chan services_bbs.CellEvent
	}
}

func (fake *FakeConvergerBBS) NewConvergeLock(convergerID string, retryInterval time.Duration) ifrit.Runner {
	fake.newConvergeLockMutex.Lock()
	fake.newConvergeLockArgsForCall = append(fake.newConvergeLockArgsForCall, struct {
		convergerID   string
		retryInterval time.Duration
	}{convergerID, retryInterval})
	fake.newConvergeLockMutex.Unlock()
	if fake.NewConvergeLockStub != nil {
		return fake.NewConvergeLockStub(convergerID, retryInterval)
	} else {
		return fake.newConvergeLockReturns.result1
	}
}

func (fake *FakeConvergerBBS) NewConvergeLockCallCount() int {
	fake.newConvergeLockMutex.RLock()
	defer fake.newConvergeLockMutex.RUnlock()
	return len(fake.newConvergeLockArgsForCall)
}

func (fake *FakeConvergerBBS) NewConvergeLockArgsForCall(i int) (string, time.Duration) {
	fake.newConvergeLockMutex.RLock()
	defer fake.newConvergeLockMutex.RUnlock()
	return fake.newConvergeLockArgsForCall[i].convergerID, fake.newConvergeLockArgsForCall[i].retryInterval
}

func (fake *FakeConvergerBBS) NewConvergeLockReturns(result1 ifrit.Runner) {
	fake.NewConvergeLockStub = nil
	fake.newConvergeLockReturns = struct {
		result1 ifrit.Runner
	}{result1}
}

func (fake *FakeConvergerBBS) ConvergeLRPs(logger lager.Logger, cellsLoader *services_bbs.CellsLoader) {
	fake.convergeLRPsMutex.Lock()
	fake.convergeLRPsArgsForCall = append(fake.convergeLRPsArgsForCall, struct {
		logger      lager.Logger
		cellsLoader *services_bbs.CellsLoader
	}{logger, cellsLoader})
	fake.convergeLRPsMutex.Unlock()
	if fake.ConvergeLRPsStub != nil {
		fake.ConvergeLRPsStub(logger, cellsLoader)
	}
}

func (fake *FakeConvergerBBS) ConvergeLRPsCallCount() int {
	fake.convergeLRPsMutex.RLock()
	defer fake.convergeLRPsMutex.RUnlock()
	return len(fake.convergeLRPsArgsForCall)
}

func (fake *FakeConvergerBBS) ConvergeLRPsArgsForCall(i int) (lager.Logger, *services_bbs.CellsLoader) {
	fake.convergeLRPsMutex.RLock()
	defer fake.convergeLRPsMutex.RUnlock()
	return fake.convergeLRPsArgsForCall[i].logger, fake.convergeLRPsArgsForCall[i].cellsLoader
}

func (fake *FakeConvergerBBS) ConvergeTasks(logger lager.Logger, timeToClaim time.Duration, convergenceInterval time.Duration, timeToResolve time.Duration, cellsLoader *services_bbs.CellsLoader) {
	fake.convergeTasksMutex.Lock()
	fake.convergeTasksArgsForCall = append(fake.convergeTasksArgsForCall, struct {
		logger              lager.Logger
		timeToClaim         time.Duration
		convergenceInterval time.Duration
		timeToResolve       time.Duration
		cellsLoader         *services_bbs.CellsLoader
	}{logger, timeToClaim, convergenceInterval, timeToResolve, cellsLoader})
	fake.convergeTasksMutex.Unlock()
	if fake.ConvergeTasksStub != nil {
		fake.ConvergeTasksStub(logger, timeToClaim, convergenceInterval, timeToResolve, cellsLoader)
	}
}

func (fake *FakeConvergerBBS) ConvergeTasksCallCount() int {
	fake.convergeTasksMutex.RLock()
	defer fake.convergeTasksMutex.RUnlock()
	return len(fake.convergeTasksArgsForCall)
}

func (fake *FakeConvergerBBS) ConvergeTasksArgsForCall(i int) (lager.Logger, time.Duration, time.Duration, time.Duration, *services_bbs.CellsLoader) {
	fake.convergeTasksMutex.RLock()
	defer fake.convergeTasksMutex.RUnlock()
	return fake.convergeTasksArgsForCall[i].logger, fake.convergeTasksArgsForCall[i].timeToClaim, fake.convergeTasksArgsForCall[i].convergenceInterval, fake.convergeTasksArgsForCall[i].timeToResolve, fake.convergeTasksArgsForCall[i].cellsLoader
}

func (fake *FakeConvergerBBS) NewCellsLoader() *services_bbs.CellsLoader {
	fake.newCellsLoaderMutex.Lock()
	fake.newCellsLoaderArgsForCall = append(fake.newCellsLoaderArgsForCall, struct{}{})
	fake.newCellsLoaderMutex.Unlock()
	if fake.NewCellsLoaderStub != nil {
		return fake.NewCellsLoaderStub()
	} else {
		return fake.newCellsLoaderReturns.result1
	}
}

func (fake *FakeConvergerBBS) NewCellsLoaderCallCount() int {
	fake.newCellsLoaderMutex.RLock()
	defer fake.newCellsLoaderMutex.RUnlock()
	return len(fake.newCellsLoaderArgsForCall)
}

func (fake *FakeConvergerBBS) NewCellsLoaderReturns(result1 *services_bbs.CellsLoader) {
	fake.NewCellsLoaderStub = nil
	fake.newCellsLoaderReturns = struct {
		result1 *services_bbs.CellsLoader
	}{result1}
}

func (fake *FakeConvergerBBS) CellEvents() <-chan services_bbs.CellEvent {
	fake.cellEventsMutex.Lock()
	fake.cellEventsArgsForCall = append(fake.cellEventsArgsForCall, struct{}{})
	fake.cellEventsMutex.Unlock()
	if fake.CellEventsStub != nil {
		return fake.CellEventsStub()
	} else {
		return fake.cellEventsReturns.result1
	}
}

func (fake *FakeConvergerBBS) CellEventsCallCount() int {
	fake.cellEventsMutex.RLock()
	defer fake.cellEventsMutex.RUnlock()
	return len(fake.cellEventsArgsForCall)
}

func (fake *FakeConvergerBBS) CellEventsReturns(result1 <-chan services_bbs.CellEvent) {
	fake.CellEventsStub = nil
	fake.cellEventsReturns = struct {
		result1 <-chan services_bbs.CellEvent
	}{result1}
}

var _ bbs.ConvergerBBS = new(FakeConvergerBBS)
